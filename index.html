<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Mini Survival</title>
<style>
body{margin:0;overflow:hidden;background:black;touch-action:none;}
canvas{display:block;}
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const bezelTop = 80;
const bezelBottom = 80;
const dangerWidth = 40;

let score = 0;
let gameOver = false;
let gameOverY = -200;

const player = {
  x: canvas.width/3,
  y: canvas.height/2,
  size: 30,
  speed: 4
};

let pipes = [];
let spawnTimer = 0;

let joystick = {
  active:false,
  startX:0,
  startY:0,
  dx:0,
  dy:0
};

canvas.addEventListener("touchstart", e=>{
  let t=e.touches[0];
  joystick.active=true;
  joystick.startX=t.clientX;
  joystick.startY=t.clientY;
});

canvas.addEventListener("touchmove", e=>{
  if(!joystick.active) return;
  let t=e.touches[0];
  joystick.dx=t.clientX-joystick.startX;
  joystick.dy=t.clientY-joystick.startY;
});

canvas.addEventListener("touchend", ()=>{
  joystick.active=false;
  joystick.dx=0;
  joystick.dy=0;
});

function spawnPipe(){
  let gap=160;
  let topHeight=Math.random()*(canvas.height-bezelTop-bezelBottom-gap);
  pipes.push({
    x:canvas.width,
    width:60,
    top:topHeight+bezelTop,
    bottom:topHeight+gap+bezelTop,
    scored:false
  });
}

function update(){
  if(gameOver){
    if(gameOverY<canvas.height/2-100) gameOverY+=10;
    return;
  }

  // 플레이어 이동
  if(joystick.active){
    player.x+=joystick.dx*0.02;
    player.y+=joystick.dy*0.02;
  }

  // 화면 제한
  player.x=Math.max(0,Math.min(canvas.width-player.size,player.x));
  player.y=Math.max(bezelTop,Math.min(canvas.height-bezelBottom-player.size,player.y));

  // 파이프 생성
  spawnTimer++;
  if(spawnTimer>90){
    spawnPipe();
    spawnTimer=0;
  }

  for(let i=pipes.length-1;i>=0;i--){
    let p=pipes[i];
    p.x-=3;

    // 충돌 검사 (상단)
    resolveCollision(p.x,bezelTop,p.width,p.top-bezelTop);

    // 충돌 검사 (하단)
    resolveCollision(p.x,p.bottom,p.width,
      canvas.height-bezelBottom-p.bottom);

    // 점수
    if(!p.scored && p.x+p.width<player.x){
      score++;
      p.scored=true;
    }

    if(p.x+p.width<0){
      pipes.splice(i,1);
    }
  }

  // 왼쪽 위험지역
  if(player.x < dangerWidth){
    gameOver=true;
  }
}

function resolveCollision(rx,ry,rw,rh){
  if(player.x < rx+rw &&
     player.x+player.size > rx &&
     player.y < ry+rh &&
     player.y+player.size > ry){

    // 겹친 거리 계산
    let overlapX = (player.x + player.size/2) - (rx + rw/2);
    let overlapY = (player.y + player.size/2) - (ry + rh/2);

    let halfWidths = (player.size/2 + rw/2);
    let halfHeights = (player.size/2 + rh/2);

    let depthX = halfWidths - Math.abs(overlapX);
    let depthY = halfHeights - Math.abs(overlapY);

    if(depthX < depthY){
      // 좌우 충돌
      if(overlapX > 0){
        // 오른쪽에서 충돌 → 왼쪽으로 밀기
        player.x += depthX;
      }else{
        // 왼쪽에서 충돌 → 오른쪽으로 밀기
        player.x -= depthX;
      }
    }else{
      // 상하 충돌
      if(overlapY > 0){
        player.y += depthY;
      }else{
        player.y -= depthY;
      }
    }
  }
}

function draw(){

  ctx.clearRect(0,0,canvas.width,canvas.height);

  // 상단 베젤
  ctx.fillStyle="#111";
  ctx.fillRect(0,0,canvas.width,bezelTop);

  // 하단 베젤
  ctx.fillRect(0,canvas.height-bezelBottom,
    canvas.width,bezelBottom);

  // 점수
  ctx.fillStyle="white";
  ctx.font="30px Arial";
  ctx.textAlign="center";
  ctx.fillText("Score: "+score,
    canvas.width/2,50);

  // 위험 그라데이션
  let grad=ctx.createLinearGradient(0,0,dangerWidth,0);
  grad.addColorStop(0,"rgba(255,0,0,0.8)");
  grad.addColorStop(1,"rgba(255,0,0,0)");
  ctx.fillStyle=grad;
  ctx.fillRect(0,bezelTop,dangerWidth,
    canvas.height-bezelTop-bezelBottom);

  // 파이프
  ctx.fillStyle="green";
  for(let p of pipes){
    ctx.fillRect(p.x,bezelTop,
      p.width,p.top-bezelTop);
    ctx.fillRect(p.x,p.bottom,
      p.width,canvas.height-bezelBottom-p.bottom);
  }

  // 플레이어
  ctx.fillStyle="cyan";
  ctx.fillRect(player.x,player.y,
    player.size,player.size);

  // 게임오버 창
  if(gameOver){
    ctx.fillStyle="white";
    ctx.fillRect(canvas.width/2-150,
      gameOverY,300,200);

    ctx.fillStyle="black";
    ctx.font="28px Arial";
    ctx.fillText("GAME OVER",
      canvas.width/2,gameOverY+60);

    ctx.fillText("Score: "+score,
      canvas.width/2,gameOverY+110);

    ctx.fillText("Tap to Restart",
      canvas.width/2,gameOverY+160);
  }

  // 조이스틱 표시
  if(joystick.active){
    ctx.beginPath();
    ctx.arc(joystick.startX,joystick.startY,40,0,Math.PI*2);
    ctx.strokeStyle="white";
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(joystick.startX+joystick.dx,
            joystick.startY+joystick.dy,
            20,0,Math.PI*2);
    ctx.fillStyle="white";
    ctx.fill();
  }
}

canvas.addEventListener("click",()=>{
  if(gameOver){
    pipes=[];
    score=0;
    player.x=canvas.width/3;
    player.y=canvas.height/2;
    gameOver=false;
    gameOverY=-200;
  }
});

function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
