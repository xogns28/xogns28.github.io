<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Mini Survival</title>
<style>
body{margin:0;overflow:hidden;background:black;touch-action:none;}
canvas{display:block;}
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const bezelTop = 80;
const bezelBottom = 80;
const dangerWidth = 40;

let score = 0;
let gameOver = false;
let gameOverY = -220;

const player = {
  x: canvas.width/3,
  y: canvas.height/2,
  size: 30,
  speed: 4
};

let pipes = [];
let spawnTimer = 0;

let joystick = {
  active:false,
  startX:0,
  startY:0,
  dx:0,
  dy:0,
  radius:50
};

/* ===== 터치 ===== */
canvas.addEventListener("touchstart", e=>{
  let t=e.touches[0];
  joystick.active=true;
  joystick.startX=t.clientX;
  joystick.startY=t.clientY;
});

canvas.addEventListener("touchmove", e=>{
  if(!joystick.active) return;

  let t=e.touches[0];
  let dx=t.clientX-joystick.startX;
  let dy=t.clientY-joystick.startY;

  let dist=Math.sqrt(dx*dx+dy*dy);

  // 작은 원이 큰 원 밖 못 나가게 제한
  if(dist>joystick.radius){
    dx = dx/dist*joystick.radius;
    dy = dy/dist*joystick.radius;
  }

  joystick.dx=dx;
  joystick.dy=dy;
});

canvas.addEventListener("touchend", ()=>{
  joystick.active=false;
  joystick.dx=0;
  joystick.dy=0;
});

/* ===== 파이프 ===== */
function spawnPipe(){
  let gap=160;
  let topHeight=Math.random()*(canvas.height-bezelTop-bezelBottom-gap);
  pipes.push({
    x:canvas.width,
    width:60,
    top:topHeight+bezelTop,
    bottom:topHeight+gap+bezelTop,
    scored:false
  });
}

/* ===== 업데이트 ===== */
function update(){
  if(gameOver){
    if(gameOverY<canvas.height/2-110) gameOverY+=10;
    return;
  }

  if(joystick.active){
    player.x+=joystick.dx*0.02;
    player.y+=joystick.dy*0.02;
  }

  // 화면 제한 (오른쪽/위/아래)
  player.x=Math.min(canvas.width-player.size,player.x);
  player.y=Math.max(bezelTop,
           Math.min(canvas.height-bezelBottom-player.size,player.y));

  // ⭐ 왼쪽 화면 끝 닿으면 게임오버
  if(player.x <= 0){
    gameOver=true;
  }

  spawnTimer++;
  if(spawnTimer>90){
    spawnPipe();
    spawnTimer=0;
  }

  for(let i=pipes.length-1;i>=0;i--){
    let p=pipes[i];
    p.x-=3;

    resolveCollision(p.x,bezelTop,p.width,p.top-bezelTop);
    resolveCollision(p.x,p.bottom,p.width,
      canvas.height-bezelBottom-p.bottom);

    if(!p.scored && p.x+p.width<player.x){
      score++;
      p.scored=true;
    }

    if(p.x+p.width<0){
      pipes.splice(i,1);
    }
  }
}

/* ===== 충돌 처리 ===== */
function resolveCollision(rx,ry,rw,rh){
  if(player.x < rx+rw &&
     player.x+player.size > rx &&
     player.y < ry+rh &&
     player.y+player.size > ry){

    let overlapX = (player.x + player.size/2) - (rx + rw/2);
    let overlapY = (player.y + player.size/2) - (ry + rh/2);

    let halfWidths = (player.size/2 + rw/2);
    let halfHeights = (player.size/2 + rh/2);

    let depthX = halfWidths - Math.abs(overlapX);
    let depthY = halfHeights - Math.abs(overlapY);

    if(depthX < depthY){
      if(overlapX > 0){
        player.x += depthX;
      }else{
        player.x -= depthX;
      }
    }else{
      if(overlapY > 0){
        player.y += depthY;
      }else{
        player.y -= depthY;
      }
    }
  }
}

/* ===== 그리기 ===== */
function draw(){

  ctx.clearRect(0,0,canvas.width,canvas.height);

  // 베젤
  ctx.fillStyle="#111";
  ctx.fillRect(0,0,canvas.width,bezelTop);
  ctx.fillRect(0,canvas.height-bezelBottom,
    canvas.width,bezelBottom);

  // 점수
  ctx.fillStyle="white";
  ctx.font="30px Arial";
  ctx.textAlign="center";
  ctx.fillText("Score: "+score,
    canvas.width/2,50);

  // 왼쪽 그라데이션
  let grad=ctx.createLinearGradient(0,0,dangerWidth,0);
  grad.addColorStop(0,"rgba(255,0,0,0.8)");
  grad.addColorStop(1,"rgba(255,0,0,0)");
  ctx.fillStyle=grad;
  ctx.fillRect(0,bezelTop,dangerWidth,
    canvas.height-bezelTop-bezelBottom);

  // 파이프
  ctx.fillStyle="green";
  for(let p of pipes){
    ctx.fillRect(p.x,bezelTop,
      p.width,p.top-bezelTop);
    ctx.fillRect(p.x,p.bottom,
      p.width,canvas.height-bezelBottom-p.bottom);
  }

  // ⭐ 플레이어 흰색
  ctx.fillStyle="white";
  ctx.fillRect(player.x,player.y,
    player.size,player.size);

  // 게임오버 박스 (어두운색)
  if(gameOver){
    ctx.fillStyle="rgba(0,0,0,0.7)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle="#222";
    ctx.fillRect(canvas.width/2-160,
      gameOverY,320,220);

    ctx.fillStyle="white";
    ctx.font="30px Arial";
    ctx.fillText("GAME OVER",
      canvas.width/2,gameOverY+70);

    ctx.fillText("Score: "+score,
      canvas.width/2,gameOverY+120);

    ctx.fillText("Tap to Restart",
      canvas.width/2,gameOverY+170);
  }

  // 조이스틱
  if(joystick.active){
    ctx.beginPath();
    ctx.arc(joystick.startX,joystick.startY,
      joystick.radius,0,Math.PI*2);
    ctx.strokeStyle="white";
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(joystick.startX+joystick.dx,
            joystick.startY+joystick.dy,
            20,0,Math.PI*2);
    ctx.fillStyle="white";
    ctx.fill();
  }
}

/* ===== 재시작 ===== */
canvas.addEventListener("click",()=>{
  if(gameOver){
    pipes=[];
    score=0;
    player.x=canvas.width/3;
    player.y=canvas.height/2;
    gameOver=false;
    gameOverY=-220;
  }
});

function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
