<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Mini Survival</title>
<style>
  body { margin:0; overflow:hidden; background:black; touch-action:none; }
  canvas { display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

/* ===== Î≤†Ï†§ ÏòÅÏó≠ ===== */
const bezelTop = 80;
const bezelBottom = 60;

/* ===== ÌîåÎ†àÏù¥Ïñ¥ ===== */
let player = {
  x: 120,
  y: canvas.height / 2,
  size: 20,
  speed: 2
};

/* ===== Ï°∞Ïù¥Ïä§Ìã± ===== */
let joystick = {
  active:false,
  startX:0,
  startY:0,
  dx:0,
  dy:0,
  radius:50
};

/* ===== Í∏∞Îë• ===== */
let pipes = [];
let pipeWidth = 60;
let pipeGap = 200;
let pipeSpeed = 3;

/* ===== Í≤åÏûÑ ÏÉÅÌÉú ===== */
let score = 0;
let gameOver = false;

/* ===== Í∏∞Îë• ÏÉùÏÑ± ===== */
function spawnPipe(){
  let gapY = Math.random() * 
    (canvas.height - bezelTop - bezelBottom - pipeGap - 100)
    + bezelTop + 50;

  pipes.push({
    x: canvas.width,
    gapY: gapY,
    hit:false,
    scored:false
  });
}

/* ===== Ï∂©Îèå Ï≤¥ÌÅ¨ ===== */
function circleRectCollision(cx, cy, radius, rx, ry, rw, rh){
  let testX = Math.max(rx, Math.min(cx, rx + rw));
  let testY = Math.max(ry, Math.min(cy, ry + rh));
  let distX = cx - testX;
  let distY = cy - testY;
  return Math.sqrt(distX*distX + distY*distY) <= radius;
}

/* ===== ÏóÖÎç∞Ïù¥Ìä∏ ===== */
function update(){
  if(gameOver) return;

  if(joystick.active){
    player.x += joystick.dx * 0.02 * player.speed;
    player.y += joystick.dy * 0.02 * player.speed;
  }

  /* ÏÉÅÌïò Ï†úÌïú */
  player.y = Math.max(bezelTop + player.size,
    Math.min(canvas.height - bezelBottom - player.size, player.y));

  for(let pipe of pipes){
    pipe.x -= pipeSpeed;

    let hitTop = circleRectCollision(
      player.x, player.y, player.size,
      pipe.x, bezelTop, pipeWidth, pipe.gapY - bezelTop
    );

    let hitBottom = circleRectCollision(
      player.x, player.y, player.size,
      pipe.x, pipe.gapY + pipeGap, pipeWidth,
      canvas.height - bezelBottom - (pipe.gapY + pipeGap)
    );

    /* Ìïú Î≤àÎßå Î∞ÄÎ¶º */
    if((hitTop || hitBottom) && !pipe.hit){
      player.x -= 15;
      pipe.hit = true;
    }

    /* Ï†êÏàò Ï≤òÎ¶¨ */
    if(pipe.x + pipeWidth < 0 && !pipe.scored){
      score++;
      pipe.scored = true;
    }
  }

  /* Í∞ÄÏãúÏóê ÎãøÏúºÎ©¥ Í≤åÏûÑÏò§Î≤Ñ */
  if(player.x <= 20){
    gameOver = true;
  }

  pipes = pipes.filter(p => p.x + pipeWidth > -10);
}

/* ===== Í∑∏Î¶¨Í∏∞ ===== */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  /* ÏÉÅÎã® Î≤†Ï†§ */
  ctx.fillStyle="#111";
  ctx.fillRect(0,0,canvas.width,bezelTop);

  /* ÌïòÎã® Î≤†Ï†§ */
  ctx.fillRect(0,canvas.height-bezelBottom,
    canvas.width,bezelBottom);

  /* Ï†êÏàò */
  ctx.fillStyle="white";
  ctx.font="28px sans-serif";
  ctx.fillText("SCORE : " + score, 20, 50);

  /* Í∞ÄÏãú */
  ctx.fillStyle="red";
  ctx.fillRect(0,bezelTop,20,
    canvas.height - bezelTop - bezelBottom);

  /* ÌîåÎ†àÏù¥Ïñ¥ */
  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(player.x,player.y,player.size,0,Math.PI*2);
  ctx.fill();

  /* Í∏∞Îë• */
  ctx.fillStyle="green";
  for(let pipe of pipes){
    ctx.fillRect(pipe.x, bezelTop,
      pipeWidth, pipe.gapY - bezelTop);

    ctx.fillRect(pipe.x,
      pipe.gapY + pipeGap,
      pipeWidth,
      canvas.height - bezelBottom - (pipe.gapY + pipeGap));
  }

  /* Ï°∞Ïù¥Ïä§Ìã± */
  if(joystick.active){
    ctx.strokeStyle="white";
    ctx.lineWidth=2;

    ctx.beginPath();
    ctx.arc(joystick.startX, joystick.startY,
      joystick.radius, 0, Math.PI*2);
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(
      joystick.startX + joystick.dx,
      joystick.startY + joystick.dy,
      20,0,Math.PI*2
    );
    ctx.fill();
  }

  /* Í≤åÏûÑÏò§Î≤Ñ ÌôîÎ©¥ */
  if(gameOver){
    ctx.fillStyle="rgba(0,0,0,0.7)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle="white";
    ctx.font="40px sans-serif";
    ctx.fillText("GAME OVER",
      canvas.width/2-130,
      canvas.height/2-40);

    ctx.font="28px sans-serif";
    ctx.fillText("FINAL SCORE : " + score,
      canvas.width/2-110,
      canvas.height/2+10);

    ctx.fillStyle="gray";
    ctx.fillRect(canvas.width/2-100,
      canvas.height/2+40,
      200,50);

    ctx.fillStyle="white";
    ctx.font="24px sans-serif";
    ctx.fillText("RESTART",
      canvas.width/2-55,
      canvas.height/2+75);
  }
}

/* ===== Î£®ÌîÑ ===== */
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}

setInterval(spawnPipe,1500);

/* ===== ÌÑ∞Ïπò ===== */
canvas.addEventListener("touchstart", e=>{
  if(gameOver){
    let x = e.touches[0].clientX;
    let y = e.touches[0].clientY;

    if(x > canvas.width/2-100 &&
       x < canvas.width/2+100 &&
       y > canvas.height/2+40 &&
       y < canvas.height/2+90){
         restartGame();
    }
    return;
  }

  let t = e.touches[0];
  joystick.active=true;
  joystick.startX=t.clientX;
  joystick.startY=t.clientY;
});

canvas.addEventListener("touchmove", e=>{
  let t=e.touches[0];
  let dx=t.clientX-joystick.startX;
  let dy=t.clientY-joystick.startY;
  let dist=Math.sqrt(dx*dx+dy*dy);
  if(dist>joystick.radius){
    dx=dx/dist*joystick.radius;
    dy=dy/dist*joystick.radius;
  }
  joystick.dx=dx;
  joystick.dy=dy;
});

canvas.addEventListener("touchend", ()=>{
  joystick.active=false;
  joystick.dx=0;
  joystick.dy=0;
});

/* ===== Ïû¨ÏãúÏûë ===== */
function restartGame(){
  player.x = 120;
  player.y = canvas.height/2;
  pipes = [];
  score = 0;
  gameOver = false;
}

loop();
</script>
</body>
</html>  player = {
    x: 100,
    y: canvas.height / 2,
    size: 20,
    speed: 2
  };
  pipes = [];
  score = 0;
  gameOver = false;
}

resetGame();

function spawnPipe(){
  let gapY = Math.random() * (canvas.height - pipeGap - 100) + 50;
  pipes.push({ x: canvas.width, gapY: gapY, counted:false });
}

function circleRectCollision(cx, cy, radius, rx, ry, rw, rh){
  let testX = cx;
  let testY = cy;

  if (cx < rx) testX = rx;
  else if (cx > rx + rw) testX = rx + rw;

  if (cy < ry) testY = ry;
  else if (cy > ry + rh) testY = ry + rh;

  let distX = cx - testX;
  let distY = cy - testY;
  return Math.sqrt(distX*distX + distY*distY) <= radius;
}

function update(){
  if(gameOver) return;

  if(joystick.active){
    player.x += joystick.dx * 0.02 * player.speed;
    player.y += joystick.dy * 0.02 * player.speed;
  }

  player.y = Math.max(player.size, Math.min(canvas.height-player.size, player.y));

  for(let pipe of pipes){
    pipe.x -= pipeSpeed;

    // Ï†êÏàò Ïπ¥Ïö¥Ìä∏ (ÏôÑÏ†ÑÌûà ÏßÄÎÇòÍ∞îÏùÑ Îïå)
    if(!pipe.counted && pipe.x + pipeWidth < 0){
      score++;
      pipe.counted = true;
    }

    if(circleRectCollision(player.x, player.y, player.size,
      pipe.x, 0, pipeWidth, pipe.gapY)){
        player.x -= 8;
    }

    if(circleRectCollision(player.x, player.y, player.size,
      pipe.x, pipe.gapY+pipeGap, pipeWidth,
      canvas.height-(pipe.gapY+pipeGap))){
        player.x -= 8;
    }
  }

  if(player.x <= 20){
    gameOver = true;
  }

  pipes = pipes.filter(p => p.x + pipeWidth > -50);
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Í∞ÄÏãú
  ctx.fillStyle="red";
  ctx.fillRect(0,0,20,canvas.height);

  // ÌîåÎ†àÏù¥Ïñ¥
  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(player.x,player.y,player.size,0,Math.PI*2);
  ctx.fill();

  // Í∏∞Îë•
  ctx.fillStyle="green";
  for(let pipe of pipes){
    ctx.fillRect(pipe.x,0,pipeWidth,pipe.gapY);
    ctx.fillRect(pipe.x,pipe.gapY+pipeGap,
      pipeWidth,canvas.height-(pipe.gapY+pipeGap));
  }

  // Ï†êÏàò ÌëúÏãú
  ctx.fillStyle="white";
  ctx.font="30px sans-serif";
  ctx.fillText("Score: " + score, 20, 40);

  // Ï°∞Ïù¥Ïä§Ìã±
  if(joystick.active){
    ctx.strokeStyle="white";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.arc(joystick.startX, joystick.startY, joystick.radius, 0, Math.PI*2);
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(
      joystick.startX + joystick.dx,
      joystick.startY + joystick.dy,
      20,
      0,
      Math.PI*2
    );
    ctx.fill();
  }

  // Í≤åÏûÑÏò§Î≤Ñ ÌôîÎ©¥
  if(gameOver){
    ctx.fillStyle="rgba(0,0,0,0.7)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle="white";
    ctx.font="40px sans-serif";
    ctx.fillText("GAME OVER",canvas.width/2-140,canvas.height/2-40);

    ctx.font="30px sans-serif";
    ctx.fillText("Final Score: " + score,
      canvas.width/2-120,canvas.height/2+10);

    // Î≤ÑÌäº
    ctx.fillStyle="white";
    ctx.fillRect(canvas.width/2-100,canvas.height/2+50,200,50);

    ctx.fillStyle="black";
    ctx.font="25px sans-serif";
    ctx.fillText("RESTART",
      canvas.width/2-55,canvas.height/2+85);
  }
}

function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}

setInterval(spawnPipe, 1500);

// ÌÑ∞Ïπò
canvas.addEventListener("touchstart", e=>{
  if(gameOver){
    let x = e.touches[0].clientX;
    let y = e.touches[0].clientY;

    if(x > canvas.width/2-100 &&
       x < canvas.width/2+100 &&
       y > canvas.height/2+50 &&
       y < canvas.height/2+100){
         resetGame();
    }
    return;
  }

  let t = e.touches[0];
  joystick.active=true;
  joystick.startX=t.clientX;
  joystick.startY=t.clientY;
});

canvas.addEventListener("touchmove", e=>{
  if(!joystick.active) return;
  let t=e.touches[0];
  let dx=t.clientX-joystick.startX;
  let dy=t.clientY-joystick.startY;
  let dist=Math.sqrt(dx*dx+dy*dy);
  if(dist>joystick.radius){
    dx=dx/dist*joystick.radius;
    dy=dy/dist*joystick.radius;
  }
  joystick.dx=dx;
  joystick.dy=dy;
});

canvas.addEventListener("touchend", ()=>{
  joystick.active=false;
  joystick.dx=0;
  joystick.dy=0;
});

loop();
</script>
</body>
</html>
let pipes = [];
let pipeWidth = 60;
let pipeGap = 180;
let pipeSpeed = 3;

let gameOver = false;

function spawnPipe(){
  let gapY = Math.random() * (canvas.height - pipeGap - 100) + 50;
  pipes.push({ x: canvas.width, gapY: gapY });
}

function circleRectCollision(cx, cy, radius, rx, ry, rw, rh){
  let testX = cx;
  let testY = cy;

  if (cx < rx) testX = rx;
  else if (cx > rx + rw) testX = rx + rw;

  if (cy < ry) testY = ry;
  else if (cy > ry + rh) testY = ry + rh;

  let distX = cx - testX;
  let distY = cy - testY;
  let distance = Math.sqrt(distX*distX + distY*distY);

  return distance <= radius;
}

function update(){
  if(gameOver) return;

  if(joystick.active){
    player.x += joystick.dx * 0.02 * player.speed; // üî• Ïù¥Îèô Í≥ÑÏàò Ï§ÑÏûÑ
    player.y += joystick.dy * 0.02 * player.speed;
  }

  player.y = Math.max(player.size, Math.min(canvas.height-player.size, player.y));

  for(let pipe of pipes){
    pipe.x -= pipeSpeed;

    if(circleRectCollision(player.x, player.y, player.size,
      pipe.x, 0, pipeWidth, pipe.gapY)){
        player.x -= 8;
    }

    if(circleRectCollision(player.x, player.y, player.size,
      pipe.x, pipe.gapY+pipeGap, pipeWidth,
      canvas.height-(pipe.gapY+pipeGap))){
        player.x -= 8;
    }
  }

  if(player.x <= 20){
    gameOver = true;
  }

  pipes = pipes.filter(p => p.x + pipeWidth > 0);
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Í∞ÄÏãú
  ctx.fillStyle="red";
  ctx.fillRect(0,0,20,canvas.height);

  // ÌîåÎ†àÏù¥Ïñ¥
  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(player.x,player.y,player.size,0,Math.PI*2);
  ctx.fill();

  // Í∏∞Îë•
  ctx.fillStyle="green";
  for(let pipe of pipes){
    ctx.fillRect(pipe.x,0,pipeWidth,pipe.gapY);
    ctx.fillRect(pipe.x,pipe.gapY+pipeGap,
      pipeWidth,canvas.height-(pipe.gapY+pipeGap));
  }

  // üéÆ Ï°∞Ïù¥Ïä§Ìã± Í∑∏Î¶¨Í∏∞
  if(joystick.active){
    ctx.strokeStyle="white";
    ctx.lineWidth=2;

    // Î∞îÍπ• Ïõê
    ctx.beginPath();
    ctx.arc(joystick.startX, joystick.startY, joystick.radius, 0, Math.PI*2);
    ctx.stroke();

    // ÏïàÏ™Ω Ïõê
    ctx.beginPath();
    ctx.arc(
      joystick.startX + joystick.dx,
      joystick.startY + joystick.dy,
      20,
      0,
      Math.PI*2
    );
    ctx.fill();
  }

  if(gameOver){
    ctx.fillStyle="white";
    ctx.font="40px sans-serif";
    ctx.fillText("GAME OVER",canvas.width/2-120,canvas.height/2);
  }
}

function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}

setInterval(spawnPipe, 1500);

canvas.addEventListener("touchstart", e=>{
  let t = e.touches[0];
  joystick.active=true;
  joystick.startX=t.clientX;
  joystick.startY=t.clientY;
});

canvas.addEventListener("touchmove", e=>{
  let t=e.touches[0];
  let dx=t.clientX-joystick.startX;
  let dy=t.clientY-joystick.startY;
  let dist=Math.sqrt(dx*dx+dy*dy);
  if(dist>joystick.radius){
    dx=dx/dist*joystick.radius;
    dy=dy/dist*joystick.radius;
  }
  joystick.dx=dx;
  joystick.dy=dy;
});

canvas.addEventListener("touchend", ()=>{
  joystick.active=false;
  joystick.dx=0;
  joystick.dy=0;
});

loop();
</script>
</body>
</html>
